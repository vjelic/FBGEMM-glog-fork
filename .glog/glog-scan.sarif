{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-a4d00d12-0db4-4d4e-9765-18c9178377f9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer (`res`) and the source buffer (`h`) is not checked before calling `memcpy`. This can be fixed by adding a check before the `memcpy` call:\n\n```cpp\nif (sizeof(res) >= sizeof(h)) {\n    memcpy(&res, &h, sizeof(__fp16));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-bf56e681-a29a-4c7a-9c42-184d82bb3847",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(&temp, &src, sizeof(uint32_t))`, if the size of `src` is larger than `temp`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before performing the copy operation.\n\nAlso, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11) which include the size of the destination as a parameter, reducing the risk of buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `memcpy_s`:\n\n```cpp\n#include <string.h>\n\nuint32_t temp;\nuint32_t src;\nsize_t size = sizeof(temp);\n\nif (size <= sizeof(src)) {\n    memcpy_s(&temp, size, &src, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the code to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f3b635cc-3590-47de-b427-191c90a6f13f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(&ret, &i, sizeof(float))`, a vulnerability could occur if the size of `i` is larger than the size of `ret`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code snippet using `memcpy_s`:\n\n```cpp\n#include <string.h>\n\nfloat i = 0.0f;\nfloat ret = 0.0f;\n\nif(sizeof(ret) >= sizeof(i)) {\n    memcpy_s(&ret, sizeof(ret), &i, sizeof(i));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only dependency required to use it is:\n\n```cpp\n#include <string.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c8a7a8b9-3309-4f47-a189-b1d9275f5b35",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `h` to `h_fp16`. If the size of `h` is larger than `h_fp16`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code snippet using `memcpy_s`:\n\n```cpp\n#include <string.h>\n\n__fp16 h_fp16;\n__fp16 h;\n\n// Ensure h_fp16 is large enough to hold h\nif(sizeof(h_fp16) >= sizeof(h)) {\n    memcpy_s(&h_fp16, sizeof(h_fp16), &h, sizeof(h));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-55932396-957a-4f54-8c7d-4de2548517c6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(&f_u32, &f, sizeof(f_u32))`, there is a potential risk if the size of `f` is larger than `f_u32`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the source and destination before performing the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(f) <= sizeof(f_u32)) {\n    memcpy(&f_u32, &f, sizeof(f_u32));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `f` is less than or equal to the size of `f_u32`. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only library dependency required by the code example is:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1cc7b2ad-abd6-49ff-86ac-ff0d628ba513",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to avoid buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nfloat ret;\nfloat val_fp32;\n// Ensure that the destination buffer is large enough\nif(sizeof(ret) >= sizeof(val_fp32)) {\n    memcpy(&ret, &val_fp32, sizeof(float));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only dependency required to use it is:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-94b76532-acc6-4141-9dc8-8cb43f5068ad",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be achieved by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `snprintf`.\n\nAdditionally, consider using modern C++ features and libraries that manage memory for you, such as `std::string` and `std::vector`, which can help prevent buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nThe following is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t copy_size = block.col_size * sizeof(inT);\nif (copy_size > (ld_out - block.col_start - i * ld_out)) {\n    // Handle error: The copy size is larger than the destination buffer.\n    return;\n}\nmemcpy(\n    out + block.col_start + i * ld_out,\n    inp + (i - block.row_start) * ld_in,\n    copy_size\n);\n```\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies beyond the standard C++ library.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-99f6ffde-3873-4956-a3d4-b5c157dc3817",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(arg)` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the terminating null character. If the string does not have a null character, `strlen(arg)` will continue reading memory until it encounters a null byte, which can lead to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen(arg)`. Also, consider using safer alternatives such as `strnlen(arg, max_len)`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(arg)` with `strnlen(arg, max_len)`. Here is an example:\n\n```cpp\n#include <string.h>\n\n// ...\n\nchar arg[] = \"example\";\nsize_t max_len = sizeof(arg) / sizeof(arg[0]) - 1;\n\nsize_t len = strnlen(arg, max_len);\n```\n\nIn this example, `max_len` is calculated as the size of the array minus one (for the null character). This ensures that `strnlen(arg, max_len)` will not read past the end of the array.\n\n## Library Dependencies\n\nThe `strlen` and `strnlen` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-eb8b275a-c7ea-4ae5-9ebd-b8c762e27576",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(&f_u32, &f, sizeof(f_u32))`, there is a potential risk if the size of `f` is larger than `f_u32`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the source and destination before performing the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(f) <= sizeof(f_u32)) {\n    memcpy(&f_u32, &f, sizeof(f_u32));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `f` is less than or equal to the size of `f_u32`. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only library dependency required by the code example is:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4b221f56-aaea-42be-b93b-521080d4342b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(beta) >= sizeof(base.alpha_data)) {\n    memcpy(beta, base.alpha_data, sizeof(ElementCompute));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only dependency required to use it is:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-68585433-45b9-4fec-92b6-46a7355e32ef",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that includes a buffer size check. For example:\n\n```cpp\n#include <cstring> // for memcpy\n#include <algorithm> // for min\n\n// ...\n\nsize_t size = std::min(sizeof(alpha), sizeof(base.alpha_data));\nstd::memcpy(alpha, base.alpha_data, size);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This header file contains definitions for functions to manipulate C strings and arrays.\n- `<algorithm>`: This header file contains definitions for a collection of function objects, which includes `std::min`.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-af583677-a7de-47fa-9678-712b154e6308",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the vulnerability arises if the value of `n * k * sizeof(T)` exceeds the size of `ref`.\n\nBuffer overflow vulnerabilities can lead to serious security issues, including arbitrary code execution, system crashes, and information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the destination buffer and the size of the data before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a size parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = n * k * sizeof(T);\nif (size <= sizeof(ref)) {\n    memcpy(ref, local.data(), size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first calculate the size of the data being copied and then check if it exceeds the size of the destination buffer before calling `memcpy`.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<cstddef>`: This library provides the `size_t` type.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7ec2fbef-3c2c-49f0-ad55-f22606a980ca",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators can lead to vulnerabilities, especially in security-sensitive applications. Functions like `rand()` from the C standard library are not suitable for cryptographic purposes because they produce predictable sequences of numbers. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, but for cryptographic purposes, consider using libraries like OpenSSL or libsodium that offer cryptographically secure random number generation.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code\n\n```cpp\n#include <algorithm>\n#include <vector>\n#include <cstdlib> // For rand()\n\nvoid shuffleVector(std::vector<int>& vec) {\n    std::random_shuffle(vec.begin(), vec.end());\n}\n```\n\n#### Fixed Code\n\n```cpp\n#include <algorithm>\n#include <vector>\n#include <random> // For std::random_device and std::mt19937\n\nvoid shuffleVector(std::vector<int>& vec) {\n    std::random_device rd;\n    std::mt19937 g(rd());\n    std::shuffle(vec.begin(), vec.end(), g);\n}\n```\n\n### Library Dependencies\n\n- `<algorithm>`: Required for `std::shuffle`.\n- `<vector>`: Required for using `std::vector`.\n- `<random>`: Required for `std::random_device` and `std::mt19937`.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-f85b9381-c03d-4e03-8a8b-b41977a4f851",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators can lead to vulnerabilities, especially in security-sensitive applications. Functions like `rand()` from the C standard library are not suitable for cryptographic purposes because they produce predictable sequences of numbers. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, but for cryptographic purposes, consider using libraries like OpenSSL or libsodium that offer cryptographically secure random number generation.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code\n\n```cpp\n#include <algorithm>\n#include <vector>\n#include <cstdlib> // For rand()\n\nvoid shuffleVector(std::vector<int>& vec) {\n    std::random_shuffle(vec.begin(), vec.end());\n}\n```\n\n#### Fixed Code\n\n```cpp\n#include <algorithm>\n#include <vector>\n#include <random> // For std::random_device and std::mt19937\n\nvoid shuffleVector(std::vector<int>& vec) {\n    std::random_device rd;\n    std::mt19937 g(rd());\n    std::shuffle(vec.begin(), vec.end(), g);\n}\n```\n\n### Library Dependencies\n\n- `<algorithm>`: Required for `std::shuffle`.\n- `<vector>`: Required for using `std::vector`.\n- `<random>`: Required for `std::random_device` and `std::mt19937`.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-43dd89c9-ecb6-414c-8857-1a3dcfd148e1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators can lead to vulnerabilities, especially in security-sensitive applications. Functions like `rand()` from the C standard library are not suitable for cryptographic purposes because they produce predictable sequences of numbers. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, but for cryptographic purposes, consider using libraries like OpenSSL or libsodium that offer cryptographically secure random number generation.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code\n\n```cpp\n#include <algorithm>\n#include <vector>\n#include <cstdlib> // For rand()\n\nvoid shuffleVector(std::vector<int>& vec) {\n    std::random_shuffle(vec.begin(), vec.end());\n}\n```\n\n#### Fixed Code\n\n```cpp\n#include <algorithm>\n#include <vector>\n#include <random> // For std::random_device and std::mt19937\n\nvoid shuffleVector(std::vector<int>& vec) {\n    std::random_device rd;\n    std::mt19937 g(rd());\n    std::shuffle(vec.begin(), vec.end(), g);\n}\n```\n\n### Library Dependencies\n\n- `<algorithm>`: Required for `std::shuffle`.\n- `<vector>`: Required for using `std::vector`.\n- `<random>`: Required for `std::random_device` and `std::mt19937`.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-a4d00d12-0db4-4d4e-9765-18c9178377f9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/fbgemm/FloatConversion.h"
                },
                "region": {
                  "startLine": 303,
                  "startColumn": 7,
                  "endLine": 303,
                  "endColumn": 38,
                  "charOffset": 10740,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(&res, &h, sizeof(__fp16)",
                    "rendered": {
                      "text": "memcpy(&res, &h, sizeof(__fp16)",
                      "markdown": "`memcpy(&res, &h, sizeof(__fp16)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/fbgemm/FloatConversion.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10740,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&res, <size of &res>,  &h,  sizeof(__fp16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bf56e681-a29a-4c7a-9c42-184d82bb3847",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/fbgemm/FloatConversion.h"
                },
                "region": {
                  "startLine": 320,
                  "startColumn": 7,
                  "endLine": 320,
                  "endColumn": 43,
                  "charOffset": 11129,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(&temp, &src, sizeof(uint32_t)",
                    "rendered": {
                      "text": "memcpy(&temp, &src, sizeof(uint32_t)",
                      "markdown": "`memcpy(&temp, &src, sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/fbgemm/FloatConversion.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11129,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&temp, <size of &temp>,  &src,  sizeof(uint32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f3b635cc-3590-47de-b427-191c90a6f13f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/fbgemm/FloatConversion.h"
                },
                "region": {
                  "startLine": 283,
                  "startColumn": 7,
                  "endLine": 283,
                  "endColumn": 37,
                  "charOffset": 10269,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(&ret, &i, sizeof(float)",
                    "rendered": {
                      "text": "memcpy(&ret, &i, sizeof(float)",
                      "markdown": "`memcpy(&ret, &i, sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/fbgemm/FloatConversion.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10269,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ret, <size of &ret>,  &i,  sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c8a7a8b9-3309-4f47-a189-b1d9275f5b35",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/fbgemm/FloatConversion.h"
                },
                "region": {
                  "startLine": 292,
                  "startColumn": 7,
                  "endLine": 292,
                  "endColumn": 41,
                  "charOffset": 10525,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(&h_fp16, &h, sizeof(__fp16)",
                    "rendered": {
                      "text": "memcpy(&h_fp16, &h, sizeof(__fp16)",
                      "markdown": "`memcpy(&h_fp16, &h, sizeof(__fp16)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/fbgemm/FloatConversion.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10525,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&h_fp16, <size of &h_fp16>,  &h,  sizeof(__fp16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-55932396-957a-4f54-8c7d-4de2548517c6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/fbgemm/FloatConversion.h"
                },
                "region": {
                  "startLine": 224,
                  "startColumn": 7,
                  "endLine": 224,
                  "endColumn": 39,
                  "charOffset": 8055,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(&f_u32, &f, sizeof(f_u32)",
                    "rendered": {
                      "text": "memcpy(&f_u32, &f, sizeof(f_u32)",
                      "markdown": "`memcpy(&f_u32, &f, sizeof(f_u32)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/fbgemm/FloatConversion.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8055,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&f_u32, <size of &f_u32>,  &f,  sizeof(f_u32)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1cc7b2ad-abd6-49ff-86ac-ff0d628ba513",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/fbgemm/FloatConversion.h"
                },
                "region": {
                  "startLine": 314,
                  "startColumn": 7,
                  "endLine": 314,
                  "endColumn": 44,
                  "charOffset": 11000,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy(&ret, &val_fp32, sizeof(float)",
                    "rendered": {
                      "text": "memcpy(&ret, &val_fp32, sizeof(float)",
                      "markdown": "`memcpy(&ret, &val_fp32, sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/fbgemm/FloatConversion.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11000,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ret, <size of &ret>,  &val_fp32,  sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-94b76532-acc6-4141-9dc8-8cb43f5068ad",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/fbgemm/OutputProcessing-inl.h"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 6,
                  "endLine": 28,
                  "endColumn": 38,
                  "charOffset": 789,
                  "charLength": 139,
                  "snippet": {
                    "text": "memcpy(\n          out + block.col_start + i * ld_out,\n          inp + (i - block.row_start) * ld_in,\n          block.col_size * sizeof(inT)",
                    "rendered": {
                      "text": "memcpy(\n          out + block.col_start + i * ld_out,\n          inp + (i - block.row_start) * ld_in,\n          block.col_size * sizeof(inT)",
                      "markdown": "`memcpy(\n          out + block.col_start + i * ld_out,\n          inp + (i - block.row_start) * ld_in,\n          block.col_size * sizeof(inT)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/fbgemm/OutputProcessing-inl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 789,
                        "charLength": 139
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n          out + block.col_start + i * ld_out, <size of \n          out + block.col_start + i * ld_out>, \n          inp + (i - block.row_start) * ld_in, \n          block.col_size * sizeof(inT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-99f6ffde-3873-4956-a3d4-b5c157dc3817",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/BenchUtils.cc"
                },
                "region": {
                  "startLine": 100,
                  "startColumn": 16,
                  "endLine": 100,
                  "endColumn": 27,
                  "charOffset": 2553,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(arg)",
                    "rendered": {
                      "text": "strlen(arg)",
                      "markdown": "`strlen(arg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/BenchUtils.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2553,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(arg, <size of arg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/BenchUtils.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2553,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(arg, <size of arg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-eb8b275a-c7ea-4ae5-9ebd-b8c762e27576",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/fbgemm/FloatConversion.h"
                },
                "region": {
                  "startLine": 215,
                  "startColumn": 7,
                  "endLine": 215,
                  "endColumn": 39,
                  "charOffset": 7787,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(&f_u32, &f, sizeof(f_u32)",
                    "rendered": {
                      "text": "memcpy(&f_u32, &f, sizeof(f_u32)",
                      "markdown": "`memcpy(&f_u32, &f, sizeof(f_u32)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/fbgemm/FloatConversion.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7787,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&f_u32, <size of &f_u32>,  &f,  sizeof(f_u32)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4b221f56-aaea-42be-b93b-521080d4342b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "fbgemm_gpu/experimental/gen_ai/src/quantize/cutlass_extensions/include/threadblock.h"
                },
                "region": {
                  "startLine": 126,
                  "startColumn": 6,
                  "endLine": 126,
                  "endColumn": 58,
                  "charOffset": 4491,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(beta, base.alpha_data, sizeof(ElementCompute)",
                    "rendered": {
                      "text": "memcpy(beta, base.alpha_data, sizeof(ElementCompute)",
                      "markdown": "`memcpy(beta, base.alpha_data, sizeof(ElementCompute)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "fbgemm_gpu/experimental/gen_ai/src/quantize/cutlass_extensions/include/threadblock.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4491,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(beta, <size of beta>,  base.alpha_data,  sizeof(ElementCompute)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-68585433-45b9-4fec-92b6-46a7355e32ef",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "fbgemm_gpu/experimental/gen_ai/src/quantize/cutlass_extensions/include/threadblock.h"
                },
                "region": {
                  "startLine": 125,
                  "startColumn": 6,
                  "endLine": 125,
                  "endColumn": 59,
                  "charOffset": 4429,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(alpha, base.alpha_data, sizeof(ElementCompute)",
                    "rendered": {
                      "text": "memcpy(alpha, base.alpha_data, sizeof(ElementCompute)",
                      "markdown": "`memcpy(alpha, base.alpha_data, sizeof(ElementCompute)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "fbgemm_gpu/experimental/gen_ai/src/quantize/cutlass_extensions/include/threadblock.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4429,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(alpha, <size of alpha>,  base.alpha_data,  sizeof(ElementCompute)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-af583677-a7de-47fa-9678-712b154e6308",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/BenchUtils.h"
                },
                "region": {
                  "startLine": 207,
                  "startColumn": 2,
                  "endLine": 207,
                  "endColumn": 45,
                  "charOffset": 4722,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(ref, local.data(), n * k * sizeof(T)",
                    "rendered": {
                      "text": "memcpy(ref, local.data(), n * k * sizeof(T)",
                      "markdown": "`memcpy(ref, local.data(), n * k * sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/BenchUtils.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4722,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ref, <size of ref>,  local.data(),  n * k * sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7ec2fbef-3c2c-49f0-ad55-f22606a980ca",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/EmbeddingSpMDMNBitBenchmark.cc"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 4,
                  "endLine": 124,
                  "endColumn": 12,
                  "charOffset": 3698,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-f85b9381-c03d-4e03-8a8b-b41977a4f851",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/EmbeddingSpMDMNBitRowWiseSparseBenchmark.cc"
                },
                "region": {
                  "startLine": 136,
                  "startColumn": 4,
                  "endLine": 136,
                  "endColumn": 12,
                  "charOffset": 3988,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-43dd89c9-ecb6-414c-8857-1a3dcfd148e1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/EmbeddingSpMDMNBit2Benchmark.cc"
                },
                "region": {
                  "startLine": 259,
                  "startColumn": 4,
                  "endLine": 259,
                  "endColumn": 12,
                  "charOffset": 8120,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}